#!/usr/bin/env python3
import argparse
import json
import os
import shlex
import shutil
import subprocess
import sys
import tempfile
import time

# Config
VERSION = "1.0.0"  # Script version
DEFAULT_REPO_URL = "https://github.com/ExistingPerson08/Spacefin-cli.git"
REPO_FOLDER_NAME = "spacefin-assets"
HOME_DIR = os.path.expanduser("~")
CACHE_DIR = os.path.join(HOME_DIR, ".cache", "spacefin-cli")
REPO_DIR = os.path.join(CACHE_DIR, REPO_FOLDER_NAME)
UPDATE_CONFIG_FILE = "update.json"


def confirm_user_repo(repo_url, skip_confirm=False):
    """Confirm user repository."""
    print(f"‚ö†Ô∏è  WARNING: You are about to use a custom repository:")
    print(f"   {repo_url}")
    print("   This could be insecure. Only proceed if you trust the source.")

    if skip_confirm:
        print("   (Skipping confirmation as requested via --skip-user-warn)")
        print("Proceeding with custom repository.")
        return

    try:
        choice = input("   Do you want to continue? [y/N]: ").strip().lower()
    except EOFError:
        choice = "n"

    if choice != "y":
        print("‚ùå Aborting.")
        sys.exit(0)
    print("Proceeding with custom repository.")


def get_repo(repo_url, refresh=False):
    """Get repository path, handling caching and updates."""
    if not os.path.exists(CACHE_DIR):
        os.makedirs(CACHE_DIR)

    is_cloned = os.path.isdir(os.path.join(REPO_DIR, ".git"))

    if not is_cloned:
        print("üì• Cloning repository...")
        try:
            subprocess.run(
                ["git", "clone", repo_url, REPO_DIR],
                check=True,
                capture_output=True,
                text=True,
                encoding="utf-8",
            )
        except subprocess.CalledProcessError as e:
            print(f"‚ùå ERROR: Failed to clone repository.")
            if e.stderr:
                print(f"   Details: {e.stderr.strip()}")
            sys.exit(1)
    else:
        # Check if update is needed (refresh flag or older than 7 days)
        should_update = refresh
        if not should_update:
            try:
                # Check .git modification time
                git_dir = os.path.join(REPO_DIR, ".git")
                last_mtime = os.path.getmtime(git_dir)
                if (time.time() - last_mtime) > (7 * 24 * 3600):
                    should_update = True
            except OSError:
                should_update = True

        if should_update:
            print("üîÑ Updating cached repository...")
            try:
                subprocess.run(
                    ["git", "-C", REPO_DIR, "pull"],
                    check=True,
                    capture_output=True,
                    text=True,
                    encoding="utf-8",
                )
            except subprocess.CalledProcessError:
                print(f"‚ö†Ô∏è  WARNING: Failed to update repository. Using cached version.")

    return REPO_DIR


def run_command(command_args, check=True):
    """Run a shell command"""
    command_for_log = " ".join(shlex.quote(s) for s in command_args)
    print(f"Running command: {command_for_log}")
    try:
        # Run and stream output
        with subprocess.Popen(
            command_args,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            encoding="utf-8",
            bufsize=1,
        ) as proc:
            if proc.stdout:
                for line in proc.stdout:
                    print(f"   > {line.strip()}", flush=True)

            proc.wait()  # Wait for the process to complete

            if check and proc.returncode != 0:
                print(f"‚ùå ERROR: Command failed with exit code {proc.returncode}")
                sys.exit(1)
            return proc.returncode

    except FileNotFoundError:
        print(f"‚ùå ERROR: Command not found: {command_args[0]}")
        sys.exit(1)
    except Exception as e:
        print(f"‚ùå ERROR: Failed to run command: {e}")
        sys.exit(1)


def list_available(path, item_type):
    """Lists available items (themes/languages)"""
    print(f"\nAvailable {item_type}:")
    if not os.path.isdir(path):
        print(f"   (Could not find '{item_type}' directory in repository)")
        return
    try:
        items = []
        for item in os.listdir(path):
            item_path = os.path.join(path, item)
            # Check if it is a directory and not hidden
            if os.path.isdir(item_path) and not item.startswith("."):
                items.append(item)

        if not items:
            print(f"   (No {item_type} found)")
        else:
            for item in sorted(items):
                print(f"  - {item}")
    except OSError as e:
        print(f"   (Error listing {item_type}: {e})")


def list_available_scripts(path):
    """Lists available scripts"""
    print(f"\nAvailable commands:")
    if not os.path.isdir(path):
        print(f"   (Could not find 'run' directory in repository)")
        return
    try:
        scripts = []
        for item in os.listdir(path):
            item_path = os.path.join(path, item)
            # Check if it is a file, ends with .sh, and not hidden
            if (
                os.path.isfile(item_path)
                and item.endswith(".sh")
                and not item.startswith(".")
            ):
                scripts.append(item[:-3])  # Remove .sh

        if not scripts:
            print(f"   (No commands found)")
        else:
            for script in sorted(scripts):
                print(f"  - {script}")
    except OSError as e:
        print(f"   (Error listing commands: {e})")


def list_available_bundles(path):
    """Lists available install bundles"""
    print(f"\nAvailable bundles:")
    if not os.path.isdir(path):
        print(f"   (Could not find 'install' directory in repository)")
        return
    try:
        bundles = []
        for item in os.listdir(path):
            item_path = os.path.join(path, item)
            # Check if it is a file, ends with .json, and not hidden
            if (
                os.path.isfile(item_path)
                and item.endswith(".json")
                and not item.startswith(".")
            ):
                bundles.append(item[:-5])  # Remove .json

        if not bundles:
            print(f"   (No bundles found)")
        else:
            for bundle in sorted(bundles):
                print(f"  - {bundle}")
    except OSError as e:
        print(f"   (Error listing bundles: {e})")


def copy(source, dest, ignore_patterns=None):
    """Wrapper for shutil.copytree with dirs_exist_ok and error handling."""
    print(f"üìÇ Copying files from '{os.path.basename(source)}' to '{dest}'...")
    try:
        shutil.copytree(source, dest, dirs_exist_ok=True, ignore=ignore_patterns)
    except TypeError:
        # Fallback for Python < 3.8 which lacks dirs_exist_ok
        print("‚ö†Ô∏è  WARNING: Your Python version is older (pre-3.8).")
        print("    Falling back to less robust copy method.")
        try:
            from distutils.dir_util import copy_tree

            copy_tree(source, dest)
        except ImportError:
            print(
                "‚ùå ERROR: 'distutils' not found. Cannot copy files on this Python version."
            )
            print("   Please upgrade to Python 3.8 or newer.")
            sys.exit(1)
        except Exception as e:
            print(f"‚ùå ERROR: Failed to copy files with distutils fallback: {e}")
            sys.exit(1)
    except Exception as e:
        print(f"‚ùå ERROR: Failed to copy files.")
        print(f"   Details: {e}")
        sys.exit(1)


def check_version_requirement(required_line):
    """Checks version requirement from script header line (e.g., '# > 1.0.0')."""
    try:
        # Strip comment char and whitespace
        content = required_line.lstrip("#").strip()
        parts = content.split()
        if len(parts) < 2:
            return True  # Invalid format, ignore

        operator = parts[0]
        req_ver_str = parts[1]

        # Simple semantic version parser (tuple comparison)
        def parse_ver(v):
            return tuple(map(int, v.split(".")))

        current = parse_ver(VERSION)
        required = parse_ver(req_ver_str)

        if operator == ">":
            return current > required
        elif operator == "<":
            return current < required
        elif operator == ">=":
            return current >= required
        elif operator == "<=":
            return current <= required
        elif operator == "=" or operator == "==":
            return current == required

        return True  # Unknown operator
    except ValueError:
        return True  # Parsing failed, ignore


# Main functions


def handle_theme(theme_name, repo_path):
    """Handles the installation of a theme."""
    print(f"üîÑ Installing theme: {theme_name}")
    themes_dir = os.path.join(repo_path, "themes")
    source_dir = os.path.join(themes_dir, theme_name)

    if not os.path.isdir(source_dir):
        print(f"‚ùå ERROR: Theme '{theme_name}' not found in repository.")
        list_available(themes_dir, "themes")
        sys.exit(1)

    # Check for DE specific folders
    de_folders = ["niri", "cosmic", "gnome"]
    found_des = []

    for de in de_folders:
        de_path = os.path.join(source_dir, de)
        if os.path.isdir(de_path):
            dest = os.path.join(HOME_DIR, ".config", de)
            print(f"üé® Found {de} configuration. Installing to {dest}...")
            copy(de_path, dest)
            found_des.append(de)

    # Copy remaining files to HOME_DIR, excluding DE folders if processed
    # If no DE folders found, proceed with standard copy
    # If DE folders found, ignore them in the main copy to avoid duplication in ~
    ignore_list = found_des if found_des else None

    # Only copy main files if there are files left other than DE folders
    # Or always copy for backward compatibility? Let's check ignore list.
    if ignore_list:
        copy(source_dir, HOME_DIR, ignore_patterns=shutil.ignore_patterns(*ignore_list))
    else:
        copy(source_dir, HOME_DIR)

    print(f"üéâ Done! Theme '{theme_name}' applied.")

    try:
        run_command(["killall", "cosmic-panel"], check=False)
    except Exception:
        pass
    print(f"‚ÑπÔ∏è  Please log out and log back in to ensure all changes apply.")


def handle_language(lang_name, repo_path):
    """Handles the installation of a language environment."""
    print(f"üîÑ Installing language environment: {lang_name}")
    lang_dir = os.path.join(repo_path, "languages")
    source_dir = os.path.join(lang_dir, lang_name)

    if not os.path.isdir(source_dir):
        print(f"‚ùå ERROR: Language '{lang_name}' not found in repository.")
        list_available(lang_dir, "languages")
        sys.exit(1)

    packages_json_path = os.path.join(source_dir, "packages.json")
    commands_json_path = os.path.join(source_dir, "commands.json")

    if os.path.exists(packages_json_path):
        print("Found 'packages.json', processing...")
        try:
            with open(packages_json_path, "r", encoding="utf-8") as f:
                packages_data = json.load(f)

            brew_packages = packages_data.get("brew")
            if brew_packages and isinstance(brew_packages, list):
                print("Installing Homebrew packages...")
                run_command(["brew", "install"] + brew_packages)

        except json.JSONDecodeError:
            print(f"‚ùå ERROR: 'packages.json' for '{lang_name}' is corrupt.")
            sys.exit(1)
        except Exception as e:
            print(f"‚ùå ERROR: Failed processing 'packages.json': {e}")
            sys.exit(1)
    else:
        print("No 'packages.json' found, skipping package installation.")

    if os.path.exists(commands_json_path):
        print("Found 'commands.json', processing...")
        try:
            with open(commands_json_path, "r", encoding="utf-8") as f:
                commands_list = json.load(f)

            if commands_list and isinstance(commands_list, list):
                print("Running setup commands...")
                for cmd_str in commands_list:
                    if not isinstance(cmd_str, str):
                        continue
                    try:
                        cmd_args = shlex.split(cmd_str)
                        if cmd_args:
                            run_command(cmd_args)
                    except ValueError as e:
                        print(f"‚ùå ERROR: Badly formatted command: {cmd_str}")
                        sys.exit(1)

        except json.JSONDecodeError:
            print(f"‚ùå ERROR: 'commands.json' for '{lang_name}' is corrupt.")
            sys.exit(1)
        except Exception as e:
            print(f"‚ùå ERROR: Failed processing 'commands.json': {e}")
            sys.exit(1)
    else:
        print("No 'commands.json' found, skipping setup commands.")

    print(f"Copying configuration files to {HOME_DIR}...")
    ignore_files = shutil.ignore_patterns("packages.json", "commands.json")
    copy(source_dir, HOME_DIR, ignore_patterns=ignore_files)

    print(f"üéâ Done! Language '{lang_name}' environment setup complete.")


def handle_run(script_name, repo_path):
    """Handles the execution of a script."""
    print(f"üîÑ Running command: {script_name}")
    run_dir = os.path.join(repo_path, "run")
    script_path = os.path.join(run_dir, f"{script_name}.sh")

    if not os.path.isfile(script_path):
        print(f"‚ùå ERROR: Command '{script_name}' not found.")
        list_available_scripts(run_dir)
        sys.exit(1)

    # Version check (3rd line)
    try:
        with open(script_path, "r", encoding="utf-8") as f:
            lines = f.readlines()
            if len(lines) >= 3:
                # Expecting format like: # >= 1.0.0
                if not check_version_requirement(lines[2]):
                    print(f"‚ùå ERROR: Script version requirement not met.")
                    print(f"   Script requires: {lines[2].strip().lstrip('#').strip()}")
                    print(f"   Current version: {VERSION}")
                    sys.exit(1)
    except Exception as e:
        print(f"‚ö†Ô∏è  WARNING: Could not check script version: {e}")

    try:
        os.chmod(script_path, 0o755)
    except Exception as e:
        print(f"‚ùå ERROR: Failed to make script executable: {e}")
        sys.exit(1)

    try:
        subprocess.run(["bash", script_path], check=True)
    except subprocess.SubprocessError as e:
        print(f"‚ùå ERROR: Failed to run command: {e}")
        sys.exit(1)


def handle_install(bundle_name, repo_path):
    """Handles the installation of a software bundle."""
    print(f"üîÑ Installing bundle: {bundle_name}")
    install_dir = os.path.join(repo_path, "install")
    json_path = os.path.join(install_dir, f"{bundle_name}.json")

    if not os.path.isfile(json_path):
        print(f"‚ùå ERROR: Bundle '{bundle_name}.json' not found in repository.")
        list_available_bundles(install_dir)
        sys.exit(1)

    print(f"Found '{bundle_name}.json', processing...")
    try:
        with open(json_path, "r", encoding="utf-8") as f:
            bundle_data = json.load(f)

        flatpak_packages = bundle_data.get("flatpak")
        if flatpak_packages and isinstance(flatpak_packages, list):
            print("Installing Flatpak packages...")
            run_command(["flatpak", "install", "-y", "--system"] + flatpak_packages)
        else:
            print("No Flatpak packages to install.")

        brew_packages = bundle_data.get("brew")
        if brew_packages and isinstance(brew_packages, list):
            print("Installing Homebrew packages...")
            run_command(["brew", "install"] + brew_packages)
        else:
            print("No Homebrew packages to install.")

    except json.JSONDecodeError:
        print(f"‚ùå ERROR: '{bundle_name}.json' is corrupt.")
        sys.exit(1)
    except Exception as e:
        print(f"‚ùå ERROR: Failed processing '{bundle_name}.json': {e}")
        sys.exit(1)

    print(f"üéâ Done! Bundle '{bundle_name}' installation complete.")


def handle_update(args, repo_path):
    """Handles system update."""
    print("üîÑ Starting system update...")

    # 1. Update Repo (Already done in main via get_repo if refresh was needed, but let's ensure)
    # The --refresh flag in main handles the repo update.

    # 2. System Update
    print("üì¶ Updating system...")
    if args.bootc:
        run_command(["sudo", "bootc", "upgrade"])
    else:
        run_command(["rpm-ostree", "upgrade"])

    # 3. Update Flatpaks & Brew
    print("üì¶ Updating applications...")
    try:
        run_command(["flatpak", "update", "-y"])
    except Exception:
        print("‚ö†Ô∏è  Flatpak update failed or not present.")

    try:
        run_command(["brew", "upgrade"])
    except Exception:
        print("‚ö†Ô∏è  Brew upgrade failed or not present.")

    # 4. Update Distrobox
    if args.distrobox:
        print("üì¶ Updating distroboxes...")
        try:
            run_command(["distrobox-upgrade", "--all"])
        except Exception:
            print("‚ö†Ô∏è  Distrobox upgrade failed.")

    # 5. Config Actions
    if not args.skip_config:
        config_path = os.path.join(repo_path, UPDATE_CONFIG_FILE)
        if os.path.isfile(config_path):
            print(f"‚öôÔ∏è  Processing {UPDATE_CONFIG_FILE}...")
            try:
                with open(config_path, "r", encoding="utf-8") as f:
                    config = json.load(f)

                update_config = config.get("update", {})

                # Copy files
                files = update_config.get("files", [])
                for file_def in files:
                    src = os.path.join(repo_path, file_def.get("src", ""))
                    dest = os.path.expanduser(file_def.get("dest", ""))
                    if os.path.exists(src):
                        if os.path.isdir(src):
                            copy(src, dest)
                        else:
                            # Ensure dest dir exists
                            os.makedirs(os.path.dirname(dest), exist_ok=True)
                            shutil.copy2(src, dest)
                            print(f"üìÇ Copied file to {dest}")

                # Run commands
                cmds = update_config.get("commands", [])
                for cmd in cmds:
                    run_command(shlex.split(cmd), check=False)

            except Exception as e:
                print(f"‚ö†Ô∏è  Failed to process config file: {e}")
        else:
            print("No extra config file found.")

    print("üéâ System update complete!")


def main():
    parser = argparse.ArgumentParser(
        description="Spacefin-cli: setup your computer",
        epilog="Example: spacefin-cli theme Cosmic",
    )
    parser.add_argument(
        "--user",
        metavar="REPO_URL",
        help="Use a custom repository.",
    )
    parser.add_argument(
        "--refresh",
        action="store_true",
        help="Force refresh of the cached repository.",
    )
    parser.add_argument(
        "--skip-user-warn",
        action="store_true",
        help="Skip confirmation for custom repository warning.",
    )

    subparsers = parser.add_subparsers(
        dest="command",
        required=True,
        title="Commands",
        metavar="<command>",
        help="The action to perform.",
    )

    # 'theme' subcommand
    theme_parser = subparsers.add_parser(
        "theme",
        help="Install a theme.",
        description="Apply a user specified theme.",
    )
    theme_parser.add_argument(
        "name", help="Name of the theme to install (e.g., 'dracula')."
    )

    # 'language' subcommand
    lang_parser = subparsers.add_parser(
        "language",
        help="Install a language environment.",
        description="Install full preconfigured development environment for the specified language.",
    )
    lang_parser.add_argument(
        "name", help="Name of the language to set up (e.g., 'python')."
    )

    # 'run' subcommand
    run_parser = subparsers.add_parser(
        "run",
        help="Run a script.",
        description="Run a script.",
    )
    run_parser.add_argument("name", help="Name of the command to run.")

    # 'install' subcommand
    install_parser = subparsers.add_parser(
        "install",
        help="Install a software bundle.",
        description="Install a bundle of applications from a .json file.",
    )
    install_parser.add_argument("name", help="Name of the bundle to install.")

    # 'update' subcommand
    update_parser = subparsers.add_parser(
        "update",
        help="Update system and tools.",
        description="Update repository, system, flatpaks and brew.",
    )
    update_parser.add_argument(
        "--bootc", action="store_true", help="Use bootc instead of rpm-ostree."
    )
    update_parser.add_argument(
        "--distrobox", action="store_true", help="Update all distroboxes."
    )
    update_parser.add_argument(
        "--skip-config",
        action="store_true",
        help="Skip custom actions from json config.",
    )

    # Handle case where no arguments are given
    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        sys.exit(1)

    args = parser.parse_args()

    # Determine repository URL logic
    # Helper to dispatch commands
    def dispatch(repo_path):
        if args.command == "theme":
            handle_theme(args.name, repo_path)
        elif args.command == "language":
            handle_language(args.name, repo_path)
        elif args.command == "run":
            handle_run(args.name, repo_path)
        elif args.command == "install":
            handle_install(args.name, repo_path)
        elif args.command == "update":
            handle_update(args, repo_path)

    try:
        if args.user:
            confirm_user_repo(args.user, skip_confirm=args.skip_user_warn)

            # Use temp dir for user repo (no cache)
            with tempfile.TemporaryDirectory() as temp_dir:
                print("üì• Cloning custom repository (temporary)...")
                repo_path = os.path.join(temp_dir, REPO_FOLDER_NAME)
                try:
                    subprocess.run(
                        ["git", "clone", args.user, repo_path],
                        check=True,
                        capture_output=True,
                        text=True,
                        encoding="utf-8",
                    )
                    dispatch(repo_path)
                except subprocess.CalledProcessError as e:
                    print(f"‚ùå ERROR: Failed to clone repository.")
                    if e.stderr:
                        print(f"   Details: {e.stderr.strip()}")
                    sys.exit(1)
        else:
            # Use cached default repo
            # Auto-refresh if update command is used
            should_refresh = args.refresh or (args.command == "update")
            repo_path = get_repo(DEFAULT_REPO_URL, refresh=should_refresh)
            dispatch(repo_path)

    except Exception as e:
        print(f"‚ùå An unexpected critical error occurred: {e}")
        import traceback

        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
